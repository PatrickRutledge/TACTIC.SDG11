// Copyright IBM Corp. 2020, 2025

import {clone, cloneDeep} from 'lodash-es'
import {parse, print, visit} from 'graphql'
import fsx from 'fs-extra'
import glob from 'glob'
import os from 'node:os'
import path from 'node:path'
import prettier from 'prettier'

import dedupeQueryAndMutationTypes from '../utils/dedupe-query-and-mutation-types.js'
import {ALL_GRAPHQL_FILES} from '../utils/constants.js'
import {getAllGraphQLFiles} from '../utils/copy-workspace-content.js'
import {rmtemp} from '../utils/rmtemp.js'

const doStitch = (source: string, output: string) => {
  // Ensure source and output directories exist
  if (!fsx.existsSync(source))
    throw new Error(`Cannot find source directory ${source}`)
  fsx.ensureDirSync(output, 0o700)

  // Get a list of files.
  let ast: any
  let files: string[] = []

  // If there's an index.graphQL - get files argument in @sdl directive
  const sourceIndex = path.join(source, 'index.graphql')

  if (fsx.existsSync(sourceIndex)) {
    const index = fsx.readFileSync(sourceIndex, 'utf8')
    ast = parse(index)
    ast = visit(ast, {
      Directive(node) {
        if (node.name.value === 'sdl') {
          const list = node.arguments?.find(
            (arg: any) => arg.name.value === 'files',
          )
          // If we find a 'files' argument, we copy the list, and remove the argument
          if (list) {
            const copy: any = clone(list.value)
            for (const file of copy.values) {
              if (file.value === ALL_GRAPHQL_FILES) {
                files = files.concat(getAllGraphQLFiles(source))
              } else {
                files = files.concat(file.value)
              }
            }
            const mutated: any = cloneDeep(node)
            mutated.arguments = mutated.arguments.filter(
              (arg: any) => arg.name.value !== 'files',
            )
            return mutated
          }
        }
      },
    })
  } else {
    const content = glob
      .sync('**/*.graphql', {cwd: source})
      .map((file: string) => {
        const graphql = fsx.readFileSync(`${source}/${file}`, 'utf8')
        return graphql
      })
    ast = parse(content.join(os.EOL))
  }

  // Strip @sdl directive
  ast = visit(ast, {
    Directive(node) {
      if (node.name.value === 'sdl') return null
    },
  })

  // Check all the files exist
  for (const file of files) {
    const find = path.join(source, file)
    if (!fsx.existsSync(find)) {
      throw new Error(
        `Cannot find file ${file} referenced in the @sdl directive in index.graphql`,
      )
    }
  }

  // Get all the files and stitch
  const printed = print(ast)
  let stitched = `${printed}${os.EOL}`
  for (const file of files) {
    const find = path.join(source, file)
    const content = fsx.readFileSync(find, 'utf8')
    stitched += `${content}${os.EOL}`
  }

  // Dedupe Query and Mutation types
  stitched = dedupeQueryAndMutationTypes(stitched)

  // Format
  stitched = prettier.format(stitched, {parser: 'graphql'})

  // Write to output folder
  const outputIndex = path.join(output, 'index.graphql')
  fsx.writeFileSync(outputIndex, stitched)

  // Copy config if exists, too
  const sourceConfig = path.join(source, 'config.yaml')
  const outputConfig = path.join(output, 'config.yaml')

  if (fsx.existsSync(sourceConfig)) {
    fsx.copyFileSync(sourceConfig, outputConfig)
  }

  // Return output folder
  return output
}

const stitch = (source: string, output?: string) => {
  if (output) {
    return doStitch(source, output)
  }

  output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`)
  try {
    return doStitch(source, output)
  } catch (error) {
    // In case of an error delete the temp output folder created earlier so that
    // it does not "leak". In case of a success, deleting the output folder is
    // the caller responsibility.
    rmtemp(output)
    throw error
  }
}

export default stitch
