// Copyright IBM Corp. 2020, 2025

import fs from 'node:fs'
import {
  ConstDirectiveNode,
  DirectiveNode,
  Kind,
  ListValueNode,
  parse,
  SchemaDefinitionNode,
  StringValueNode,
  OperationTypeNode,
  visit,
} from 'graphql'
import path from 'node:path'

import {cloneDeep, DeepWriteable} from './graphql-helpers.js'
import print from '../actions/print.js'
import {ALL_GRAPHQL_FILES} from './constants.js'
import {getAllGraphQLFiles} from './copy-workspace-content.js'

const normalizePathSep = (pathlike: string) =>
  pathlike.replace(path.sep, path.posix.sep)

export const createOrUpdateSdlDirective = (
  importedGraphQLFiles: readonly string[],
  allGraphQLFiles: readonly string[],
  origSdlDirective?: DirectiveNode | ConstDirectiveNode,
): ConstDirectiveNode => {
  let sdlDirective: DeepWriteable<DirectiveNode>
  if (origSdlDirective) {
    sdlDirective = cloneDeep(origSdlDirective)
  } else {
    sdlDirective = {
      kind: Kind.DIRECTIVE,
      name: {
        kind: Kind.NAME,
        value: 'sdl',
      },
      arguments: [
        {
          kind: Kind.ARGUMENT,
          name: {
            kind: Kind.NAME,
            value: 'files',
          },
          value: {
            kind: Kind.LIST,
            values: [
              {
                kind: Kind.STRING,
                value: ALL_GRAPHQL_FILES,
              },
            ],
          },
        },
      ],
    }
  }

  sdlDirective.arguments = sdlDirective.arguments?.map(arg => {
    if (arg.name.value === 'files') {
      const filesValueNodes = arg.value as DeepWriteable<ListValueNode>
      const fileset = new Set<string>(
        [
          ...filesValueNodes.values.map(
            value => (value as StringValueNode).value,
          ),
          ...importedGraphQLFiles,
          // Make sure paths in the `@sdl()` directive use the `/` separator
          // even on Windows.
        ].map(normalizePathSep),
      )
      if (fileset.has(ALL_GRAPHQL_FILES)) {
        fileset.delete(ALL_GRAPHQL_FILES)
        allGraphQLFiles.forEach(file => fileset.add(normalizePathSep(file)))
      }
      filesValueNodes.values = [...fileset].map(file => ({
        kind: Kind.STRING,
        value: file,
      }))
    }
    return arg
  })

  return sdlDirective as ConstDirectiveNode
}

export const createSchemaElement = (
  importedGraphQLFiles: readonly string[],
  allGraphQLFiles: readonly string[],
): SchemaDefinitionNode => {
  const schemaElement = {
    kind: Kind.SCHEMA_DEFINITION,
    directives: [
      createOrUpdateSdlDirective(importedGraphQLFiles, allGraphQLFiles),
    ],
    operationTypes: [
      {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation: OperationTypeNode.QUERY,
        type: {
          kind: Kind.NAMED_TYPE,
          name: {
            kind: Kind.NAME,
            value: 'Query',
          },
        },
      },
    ],
  } satisfies SchemaDefinitionNode

  return schemaElement
}

export default (source: string, importedGraphQLFiles: readonly string[]) => {
  const allGraphQLFiles = getAllGraphQLFiles(source)

  const output = path.join(source, 'index.graphql')
  const index = fs.readFileSync(output, 'utf8')

  let hasSchemaElement
  let ast = parse(index)
  ast = visit(ast, {
    SchemaDefinition(node) {
      hasSchemaElement = true
      const mutated = cloneDeep(node)
      const idx = mutated.directives?.findIndex(
        directive => directive.name.value === 'sdl',
      )
      if (mutated.directives && idx !== undefined && idx > -1) {
        ;(mutated.directives[idx] as DirectiveNode) =
          createOrUpdateSdlDirective(
            importedGraphQLFiles,
            allGraphQLFiles,
            mutated.directives[idx],
          )
      } else {
        mutated.directives = mutated.directives || []
        mutated.directives.push(
          createOrUpdateSdlDirective(
            importedGraphQLFiles,
            allGraphQLFiles,
          ) as DeepWriteable<ConstDirectiveNode>,
        )
      }
      return mutated
    },
  })

  if (!hasSchemaElement) {
    ast = visit(ast, {
      Document(node) {
        const mutated = cloneDeep(node)
        mutated.definitions.push(
          createSchemaElement(
            importedGraphQLFiles,
            allGraphQLFiles,
          ) as DeepWriteable<SchemaDefinitionNode>,
        )
        return mutated
      },
    })
  }

  fs.writeFileSync(output, print(ast))
}
