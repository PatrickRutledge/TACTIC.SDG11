// Copyright IBM Corp. 2020, 2025

import debug from 'debug'
import {ASTNode, BREAK, GraphQLSchema, Kind, visit} from 'graphql'
import {buildSchema} from 'graphql/utilities/index.js'
import fetch from '@stepzen/fetch'
import fsx from 'fs-extra'
import glob from 'glob'
import os from 'node:os'
import path from 'node:path'
import {replace} from 'lodash-es'

import {cloneDeep} from '../utils/graphql-helpers.js'
import {STEPZEN_SERVER_URL} from './constants.js'

import configure from '../actions/configure.js'
import transpile from '../actions/transpile.js'
import {rmtemp} from './rmtemp.js'

export const dedupeTempFolder = (dirpath: string) => {
  do {
    dirpath = replace(dirpath, os.tmpdir(), '')
  } while (dirpath.includes(os.tmpdir()))

  dirpath = path.join(os.tmpdir(), dirpath)

  return dirpath
}

export const findNextAvailableSubfolder = (folder: string, name: string) => {
  let subfolder = name
  let counter = 1
  while (fsx.existsSync(path.join(folder, subfolder))) {
    const suffix = `${counter++}`.padStart(2, '0')
    subfolder = `${name}-${suffix}`
  }

  return subfolder
}

const isQueryMutationSubscription = (
  ancestors: readonly (ASTNode | readonly ASTNode[])[],
) => {
  if (Array.isArray(ancestors[ancestors.length - 1])) {
    return false
  }

  const ancestor = ancestors[ancestors.length - 1] as ASTNode
  return (
    ancestor.kind === Kind.OBJECT_TYPE_DEFINITION &&
    ['Query', 'Mutation', 'Subscription'].includes(ancestor.name.value)
  )
}

export const findQueryMutationInSchema = (
  name: string,
  files: any,
): Boolean => {
  for (const file of files) {
    let found = false
    visit(file.ast, {
      FieldDefinition(node, _key, _parent, _path, ancestors) {
        if (
          isQueryMutationSubscription(ancestors) &&
          node.name.value === name
        ) {
          found = true
          return BREAK
        }
      },
    })
    if (found) return true
  }
  return false
}

export const findTypeInSchema = (name: string, files: any): Boolean => {
  for (const file of files) {
    let found = false
    visit(file.ast, {
      ObjectTypeDefinition(node) {
        if (node.name.value === name) {
          found = true
          return BREAK
        }
      },
    })
    if (found) return true
  }
  return false
}

export const getConfiguration = async (
  directories: string[],
  silent: boolean = false,
  answers: any = {},
): Promise<Record<string, any> | undefined> => {
  const tmp = path.join(os.tmpdir(), `stepzen-tmp-config-${Date.now()}`)
  fsx.ensureDirSync(tmp)

  try {
    for (const directory of directories) {
      const configs = [
        ...glob.sync('**/config.yaml', {cwd: directory}),
        ...glob.sync('**/stepzen.config.json', {cwd: directory}),
      ]

      for (const config of configs) {
        const configFolder = path.join(directory, config)

        let writeFolder = path.join(tmp, directory, config)
        writeFolder = dedupeTempFolder(writeFolder)

        const content = fsx.readFileSync(configFolder, 'utf8')

        fsx.ensureFileSync(writeFolder)
        fsx.writeFileSync(writeFolder, content, {mode: 0o600})
      }
    }

    const configuration = await configure(tmp, silent, answers)
    return configuration
  } finally {
    rmtemp(tmp)
  }
}

export const getExtensions = async (): Promise<string> => {
  const baseurl = STEPZEN_SERVER_URL.replace('.io', '.net').replace(
    '{account}',
    'stepzen',
  )
  const url = `${baseurl}/directives.graphql`

  const startedAt = new Date().getTime()
  debug('stepzen:extensions')(
    `[transpiler] fetching StepZen extensions from ${url}`,
  )

  const response = await fetch(url)
  const text = await response.text()

  const doneAt = new Date().getTime()
  debug('stepzen:extensions')(
    `[transpiler] fetched extensions (${text.length} bytes, ${
      doneAt - startedAt
    } ms)`,
  )

  return text
}

export const getSchema = async (
  directory: string,
  extensions: string,
): Promise<GraphQLSchema> => {
  const transpiled = await transpile(directory)
  return buildSchema(`${extensions}${os.EOL}${transpiled.schema}`)
}

export const mergeQueryMutationIntoSchema = (type: any, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        FieldDefinition(node, _key, _parent, _path, ancestors) {
          if (
            isQueryMutationSubscription(ancestors) &&
            node.name.value === type.name.value
          ) {
            const directives = cloneDeep(type.directives)
            const mutated: any = cloneDeep(node)
            mutated.directives = directives
            return mutated
          }
        },
      }),
    }
  })
  return files
}

export const mergeTypeIntoSchema = (type: any, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        ObjectTypeDefinition(node) {
          if (node.name.value === type.name.value) {
            const directives = cloneDeep(type.directives)
            const fields = cloneDeep(type.fields)
            const mutated: any = cloneDeep(node)
            mutated.directives = directives
            mutated.fields = fields
            return mutated
          }
        },
      }),
    }
  })
  return files
}

export const removeQueryMutationFromSchema = (name: string, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        FieldDefinition(node, _key, _parent, _path, ancestors) {
          if (
            isQueryMutationSubscription(ancestors) &&
            node.name.value === name
          ) {
            return null
          }
        },
      }),
    }
  })
  return files
}

export const removeTypeFromSchema = (name: string, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        ObjectTypeDefinition(node) {
          if (node.name.value === name) {
            return null
          }
        },
      }),
    }
  })
  return files
}
