// Copyright IBM Corp. 2020, 2025

import fsx from 'fs-extra'
import glob from 'glob'
import {mergeTypeDefs} from '@graphql-tools/merge'
import {parse, visit} from 'graphql'
import os from 'node:os'
import path from 'node:path'
import yaml from 'yaml'

import {
  dedupeTempFolder,
  findQueryMutationInSchema,
  findTypeInSchema,
  getSchema,
  mergeQueryMutationIntoSchema,
  removeQueryMutationFromSchema,
  mergeTypeIntoSchema,
  removeTypeFromSchema,
  getConfiguration,
  findNextAvailableSubfolder,
  getExtensions,
} from '../utils/merge-helpers.js'
import print from './print.js'
import setFilesInSDL from '../utils/set-files-in-sdl.js'
import stripEmptyQueriesAndMutations from '../utils/strip-empty-queries-and-mutations.js'
import copyWorkspaceContent from '../utils/copy-workspace-content.js'
import {ALL_GRAPHQL_FILES} from '../utils/constants.js'
import {rmtemp} from '../utils/rmtemp.js'

// It's safe to use this special placeholder value here: in case of a failure
// in the merge / import process it will not reach the workspace folder.
// All intermediary steps are carried out in a temp folder, and only when all
// merge / import steps are completed, the result it copied over to the
// workspace folder.
const BLANK_INDEX_TEMPLATE = `
schema @sdl(files: ["${ALL_GRAPHQL_FILES}"]) {
  query: Query
}
`.trim()

const BLANK_QUERY_TYPE = `
type Query {
  __query: String
}
`.trim()

export type MergeOptions = {
  answers: any
  output: string | null
  silent: boolean
  /** when `false` merge only covers config files and updates @sdl directrive */
  mergeTypes?: boolean
  /** merge behaviour when a schema with the given name exists in the source */
  onConflict?: 'overwrite' | 'append'
  extensions?: string
}

const doMerge = async (
  original: string,
  imported: {
    name: string
    source: string
  },
  options: MergeOptions & {output: string},
) => {
  if (!options.answers) options.answers = {}
  if (!options.silent) options.silent = false
  if (options.mergeTypes === undefined) options.mergeTypes = true
  if (options.onConflict === undefined) options.onConflict = 'append'
  if (!options.extensions) options.extensions = await getExtensions()

  // To stop things like
  // C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-config-1638293497187\C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-1638293496286
  options.output = dedupeTempFolder(options.output)

  // Ensure original, importing and output directories exist
  if (!fsx.existsSync(original))
    throw new Error(`Cannot find original directory ${original}`)
  if (!fsx.existsSync(imported.source))
    throw new Error(`Cannot find imported source directory ${imported.source}`)
  fsx.ensureDirSync(options.output, 0o700)

  // Copy the original into the output.
  copyWorkspaceContent(original, options.output)

  // Ensure an index.graphql exists
  const outputIndex = path.join(options.output, 'index.graphql')
  if (!fsx.existsSync(outputIndex)) {
    fsx.writeFileSync(
      outputIndex,
      options.mergeTypes
        ? // (2022-03-09, vluakshov) Not sure what'd break without the
          // blank Query type, but that's why I do not want to remove it
          // from the default code path.
          BLANK_INDEX_TEMPLATE + BLANK_QUERY_TYPE
        : // In the non-default code path that does NOT merge types
          // the blank Query type causes explicit problems
          // (https://github.com/steprz/stepzen-cli/issues/482).
          BLANK_INDEX_TEMPLATE,
    )
  }

  const targetSubfolder =
    options.onConflict === 'overwrite'
      ? imported.name
      : findNextAvailableSubfolder(original, imported.name)

  let importedGraphQLFiles: string[] = []
  if (options.mergeTypes) {
    const merged = mergeTypeDefs([
      await getSchema(options.output, options.extensions),
      await getSchema(imported.source, options.extensions),
    ])

    let queries: any[] = []
    let mutations: any[] = []
    let types: any[] = []

    visit(merged, {
      ObjectTypeDefinition(node) {
        if (node.name.value === 'Query') queries = queries.concat(node.fields)
        else if (node.name.value === 'Mutation')
          mutations = mutations.concat(node.fields)
        else types = types.concat(node)
      },
    })

    const details = {
      original: glob.sync('**/*.graphql', {cwd: options.output}).map(file => {
        const content = fsx.readFileSync(`${options.output}/${file}`, 'utf8')
        return {ast: parse(content), file}
      }),
      imported: glob.sync('**/*.graphql', {cwd: imported.source}).map(file => {
        const content = fsx.readFileSync(`${imported.source}/${file}`, 'utf8')
        return {ast: parse(content), file}
      }),
    }

    // Merge Queries and Mutations
    for (const type of [...queries, ...mutations]) {
      const isInOriginal = findQueryMutationInSchema(
        type.name.value,
        details.original,
      )
      const isInImported = findQueryMutationInSchema(
        type.name.value,
        details.imported,
      )

      if (isInOriginal && isInImported) {
        details.original = mergeQueryMutationIntoSchema(type, details.original)
        details.imported = removeQueryMutationFromSchema(
          type.name.value,
          details.imported,
        )
      }
    }

    // Merge Types
    for (const type of types) {
      const isInOriginal = findTypeInSchema(type.name.value, details.original)
      const isInImported = findTypeInSchema(type.name.value, details.imported)

      if (isInOriginal && isInImported) {
        details.original = mergeTypeIntoSchema(type, details.original)
        details.imported = removeTypeFromSchema(
          type.name.value,
          details.imported,
        )
      }
    }

    // Clean up the files. Remove empty Query / Mutation types, filter out now-empty files
    const cleaned = {
      original: details.original
        .map(item => ({
          ...item,
          ast: stripEmptyQueriesAndMutations(item.ast),
        }))
        .filter(item => item.ast.definitions.length > 0),
      imported: details.imported
        .map(item => ({
          ...item,
          ast: stripEmptyQueriesAndMutations(item.ast),
        }))
        .filter(item => item.ast.definitions.length > 0),
    }

    // Write the files to the output directory
    cleaned.original.forEach((a: any) => {
      // eslint-disable-next-line
      const file = path.join(options.output as any, a.file)
      const deduped = dedupeTempFolder(file)

      fsx.ensureFileSync(deduped)
      fsx.writeFileSync(deduped, print(a.ast))
    })

    cleaned.imported.forEach(a => {
      // eslint-disable-next-line
      const file = path.join(options.output as any, targetSubfolder, a.file)
      const deduped = dedupeTempFolder(file)

      fsx.ensureFileSync(deduped)
      fsx.writeFileSync(deduped, print(a.ast))
      importedGraphQLFiles.push(path.relative(options.output, deduped))
    })
  } else {
    glob.sync('**/*.graphql', {cwd: imported.source}).forEach(relativePath => {
      const importedFullPath = path.join(imported.source, relativePath)
      const targetFullPath = path.join(
        options.output,
        targetSubfolder,
        relativePath,
      )
      fsx.ensureDirSync(path.dirname(targetFullPath))
      fsx.copyFileSync(importedFullPath, targetFullPath)
      importedGraphQLFiles.push(path.relative(options.output, targetFullPath))
    })
  }

  // Make sure all files are referenced in @sdl
  setFilesInSDL(options.output, importedGraphQLFiles)

  // Generate configuration
  const config = await getConfiguration(
    [options.output, imported.source],
    options.silent,
    options.answers,
  )
  if (config) {
    const configFile = path.join(options.output, 'config.yaml')
    fsx.writeFileSync(configFile, yaml.stringify(config), {mode: 0o600})
  }

  // Return a merged schema!
  return options.output
}

const merge = (
  original: string,
  imported: {
    name: string
    source: string
  },
  options: MergeOptions = {
    answers: {},
    output: null,
    silent: false,
    mergeTypes: true,
    onConflict: 'append',
    extensions: '',
  },
) => {
  // Make sure there is an output directory
  if (options.output) {
    return doMerge(
      original,
      imported,
      options as MergeOptions & {output: string},
    )
  }

  const output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`)
  try {
    return doMerge(original, imported, {...options, output})
  } catch (error) {
    // In case of an error delete the temp output folder created earlier so that
    // it does not "leak". In case of a success, deleting the output folder is
    // the caller responsibility.
    rmtemp(output)
    throw error
  }
}

export default merge
