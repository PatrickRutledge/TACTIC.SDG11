// Copyright IBM Corp. 2020, 2025

// This file contains helpers that zip a file or directory

import archiver from 'archiver'
import debug from 'debug'
import FormData from 'form-data'
import fs from 'node:fs'
import glob from 'glob'
import os from 'node:os'
import path from 'node:path'
import yaml from 'yaml'
import {transpileConfigurationset} from './transpiling.js'
import {validateConfigurationset} from './validation.js'
import {Configuration, SchemaFiles} from './types.js'
import {rmtemp} from './rmtemp.js'

type YamlPayload = FormData
type ZipPayload = FormData

// This function takes a (yaml) file path
// and creates a FormData payload, containing the yaml content as 'yaml'
export const generateYamlPayload = async (
  file: string | undefined,
): Promise<YamlPayload> => {
  return new Promise((resolve, reject) => {
    const payload = new FormData()

    if (file) {
      if (!fs.existsSync(file)) {
        reject(new Error(`File does not exist: ${file}`))
      }
      const content = fs.readFileSync(file, 'utf8')
      debug('stepzen:sdk:payload')(`adding YAML payload\n${content}`)
      payload.append('yaml', fs.readFileSync(file))
      resolve(payload)
    } else {
      reject(new Error('File not specified'))
    }
  })
}

// This function takes a directory path, and optional data object,
// and creates a FormData payload, containing the directory contents as 'zip',
// and any other items in the data object.
export const generateZipPayload = async (
  directory: string | undefined,
  data: object | undefined,
  filters: RegExp[],
): Promise<ZipPayload> => {
  return new Promise((resolve, reject) => {
    const payload = new FormData()

    if (data) {
      for (const [key, value] of Object.entries(data)) {
        payload.append(key, value)
      }
    }

    // Store it in /tmp. Create a WriteStream
    const filepath = path.join(os.tmpdir(), `stepzen-payload-${Date.now()}.zip`)
    const output = fs.createWriteStream(filepath, {mode: 0o600})

    // We're making a zip file
    const archive = archiver('zip', {
      zlib: {level: 9},
    })

    archive.on('error', error => {
      fs.unlinkSync(filepath)
      reject(error)
    })

    // We're piping it to the WriteStream
    archive.pipe(output)

    // If we've specified a directory, add it to the archive
    if (directory) {
      if (!fs.existsSync(directory)) {
        reject(new Error(`Directory does not exist: ${directory}`))
      }

      // Get all the files in the directory (and all subdirectories).
      const allFiles = glob.sync('**', {cwd: directory})

      // Loop through each file, because we want to filter them
      // We add them manually, because when we use glob, it embeds
      // a full path, and we want everything to explicitly
      // start at the root of the archive.
      allFiles.forEach(file => {
        const include = filters.some(filter => file.match(filter))

        if (include) {
          debug('stepzen:archive')(file)
          archive.file(path.join(directory, file), {name: file})
        }
      })
    }

    // Once we're done, append a ReadStream to the tmp file
    output.on('close', () => {
      const stream = fs.createReadStream(filepath)
      payload.append('zip', stream)
      // Remove the temporary zip
      stream.on('close', () => {
        fs.unlinkSync(filepath)
      })
      // This is where we return the payload
      resolve(payload)
    })

    // Archive the file or directory
    archive.finalize()
  })
}

export const generateSchemaFilesPayload = (
  workspaceFolderPath: string,
): SchemaFiles => {
  if (!fs.existsSync(workspaceFolderPath)) {
    throw new Error(
      `Failed to read folder ${workspaceFolderPath}. Does it exist?`,
    )
  }

  const files = glob
    .sync('**/*.graphql', {cwd: workspaceFolderPath})
    .map(file => {
      return {
        name: file,
        content: fs.readFileSync(`${workspaceFolderPath}/${file}`, 'utf8'),
      }
    })

  if (files.length === 0) {
    throw new Error(
      `Failed to find any .graphql files in ${workspaceFolderPath}`,
    )
  }

  return {
    files,
    entryPoint: 'index.graphql',
  }
}

export const generateConfigurationPayload = async (
  configFilePath?: string,
): Promise<Configuration | null> => {
  if (!configFilePath) {
    return null
  }

  await validateConfigurationset(configFilePath)
  const transpiled = await transpileConfigurationset(configFilePath)
  try {
    debug('stepzen:sdk')(`effective config written to ${transpiled}`)
    const content = fs.readFileSync(transpiled, 'utf-8')
    return yaml.parse(content, {schema: 'failsafe'}) || null
  } finally {
    rmtemp(path.dirname(transpiled))
  }
}
