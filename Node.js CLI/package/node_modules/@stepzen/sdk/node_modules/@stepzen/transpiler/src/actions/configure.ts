// Copyright IBM Corp. 2020, 2025

import debug from 'debug'
import fsx from 'fs-extra'
import glob from 'glob'
import inquirer from 'inquirer'
import path from 'node:path'
import yaml from 'yaml'

/**
 * Get effective StepZen endpoint configuration for a directory:
 * Traverse the file system starting at `source` and
 *  - merge all `config.yaml` files (discarding unrecognized properties)
 *  - merge all `config` sections from `stepzen.config.json` files
 *
 * Possibly, interactive: if `silent` is `false` and there are non-empty
 * `config` sections in `stepzen.config.json` files.
 */
export default async (
  source: string,
  silent = false,
  answers: any = {},
): Promise<Record<string, any> | undefined> => {
  const config = {
    configurationset: [] as any[],
    ruleset: [] as any[],
    access: undefined as any,
    deployment: undefined as any,
  }

  debug('stepzen:transpiler:config')(`getting effective config for ${source}`)

  // Now let's parse and add any config.yamls
  let configYamlCount = 0
  for (const y of glob.sync('**/config.yaml', {cwd: source})) {
    const filePath = path.join(source, y)

    const file = fsx.readFileSync(filePath, 'utf8')
    let asYAML
    try {
      asYAML = yaml.parse(file, {schema: 'failsafe'})
    } catch (error) {
      debug('stepzen:transpiler:config')(
        `Ignoring an invalid config.yaml ${filePath}.` +
          ` YAML parse error: ${error}`,
      )
      continue
    }

    if (!asYAML) {
      debug('stepzen:transpiler:config')(
        `ignoring an empty config.yaml ${filePath}`,
      )
      continue
    }

    configYamlCount += 1
    debug('stepzen:transpiler:config')(
      `adding config.yaml ${filePath}:\n${JSON.stringify(asYAML, null, 2)}`,
    )

    // strip away any non-recognized properties
    Object.entries(asYAML).forEach(([keyAsAny, value]) => {
      if (Object.prototype.hasOwnProperty.call(config, keyAsAny)) {
        const key = keyAsAny as keyof typeof config
        config[key] = Array.isArray(config[key])
          ? config[key].concat(value)
          : value
      } else {
        debug('stepzen:transpiler:config')(
          `ignoring unrecognized config property ${keyAsAny}`,
        )
      }
    })
  }

  debug('stepzen:transpiler:config')(
    `done adding **/config.yaml files (processed: ${configYamlCount})`,
  )

  // Now let's build configs from questions
  let configJsonCount = 0
  for await (const j of glob.sync('**/stepzen.config.json', {
    cwd: source,
  })) {
    const filePath = path.join(source, j)

    const file = fsx.readFileSync(filePath, 'utf8')
    const asJSON = JSON.parse(file)

    configJsonCount += 1
    debug('stepzen:transpiler:config')(
      `adding stepzen.config.json ${filePath}:` +
        `\n${JSON.stringify(asJSON, null, 2)}`,
    )

    if (asJSON.config?.questions) {
      for await (const question of asJSON.config?.questions) {
        const [name, key] = question.name.split('.')

        let answer: any = {}

        if (silent) {
          answer = {
            [name]: {[key]: answers[name]?.[key] ? answers[name]?.[key] : ''},
          }
        } else {
          answer = await inquirer.prompt({
            type: 'password',
            ...question,
          })
        }

        const configset = {
          configuration: {
            name,
            [key]: answer[name][key],
          },
        }

        debug('stepzen:transpiler:config')(
          `question: ${JSON.stringify(question, null, 2)}`,
        )
        debug('stepzen:transpiler:config')(
          `answer: ${JSON.stringify(configset, null, 2)}`,
        )

        config.configurationset.push({...configset})
      }
    }
  }

  debug('stepzen:transpiler:config')(
    `done adding **/stepzen.config.json files (processed: ${configJsonCount})`,
  )

  debug('stepzen:transpiler:config')(
    `combined content of all config files:` +
      `\n${JSON.stringify(config, null, 2)}`,
  )

  // OK now let's collate everything into shared configurations
  const configurationset = []
  {
    const obj: any = {}
    for (const c of config.configurationset) {
      const name = c.configuration.name
      if (!obj[name]) obj[name] = {}
      for (const [key, value] of Object.entries(c.configuration)) {
        if (key === name) continue
        obj[name][key] = value
      }
    }

    for (const configuration of Object.keys(obj)) {
      configurationset.push({
        configuration: {...obj[configuration]},
      })
    }
  }

  // Now convert back into StepZen format
  const structured = Object.fromEntries(
    Object.entries({...config, configurationset}).filter(([_key, value]) =>
      Array.isArray(value) ? value.length > 0 : value !== undefined,
    ),
  )

  // Return YAML, if appropriate
  if (Object.keys(structured).length > 0) {
    debug('stepzen:transpiler:config')(
      `effective config:\n${yaml.stringify(structured)}`,
    )
    return structured
  }

  debug('stepzen:transpiler:config')(
    `Could not find any of the supported properties in the config:` +
      ` [ '${Object.keys(config).join(`', '`)}' ].` +
      ` Retuning <undefined> meaning 'effective config is empty'.`,
  )
}
